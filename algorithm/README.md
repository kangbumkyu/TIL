# 알고리즘

## 정렬

### 버블 정렬

- 자신과 옆에 요소와 비교해서 올바른 순서로 정렬하는 과정을 반복하는 정렬
- 한 번 반복문을 돌때마다 가장 큰 값이 마지막에 위치하게 됨
- 시간 복잡도: O(N^2)

예시) 배열: [3, 2, 5, 1, 4]

1. 첫번째 요소와 두번째 요소를 비교해 첫번째가 두번째보다 크면 서로의 위치를 바꾼다. 첫번째가 작으면 위치를 바꾸지 않는다.
   [2, 3, 5, 1, 4]

2. 두번째 요소와 세번째 요소를 비교해 정렬한다.
   [2, 3, 5, 1, 4] (3 < 5 이기 때문에 위치를 바꾸지 않는다.)

3. 세번째 요소와 네번째 요소를 비교해 정렬한다.
   [2, 3, 1, 5, 4]

4. 네번째 요소와 다섯번째 요소를 비교해 정렬한다.
   [2, 3, 1, 4, 5]

5. 모든 요소에 대해서 1회 훑으면 마지막 요소엔 항상 가장 큰 수가 위치해 있다. 따라서 1 ~ 4번 스텝을 n-1회 반복하면 배열은 정렬된 상태가 된다.
   [1, 2, 3, 4, 5]

자신과 옆에 요소를 비교해 정렬를 하는 모습이 마치 거품이 생성되는 것 같다고 해서 버블정렬이라고 한다. 한 세트를 비교하는데 n번에 시간이 들고, 총 n - 1세트를 반복해야 하기 때문에 시간 복잡도는 n \* (n-1) = O(N^2) 이 된다.

[소스코드](https://github.com/kangbumkyu/TIL/blob/main/algorithm/sorting/bubble.c#L11)
<br>

### 삽입 정렬

- 삽입 정렬은 배열에서 하나의 값(키)을 뽑고 뽑은 값과 그 전에 방문한 요소를 비교해서 정렬하는 방식이다.
- 이미 방문한 요소는 정렬이 된 상태다.
- 시간 복잡도: O(N^2)

<br>

예를 살펴보자. 배열 [5, 3, 2, 4, 1] 을 삽입 정렬을 사용해 정렬을 해보겠다.

1. 두 번째 요소를 선택하고, 두번째 요소와 첫번째 요소를 비교한 후 정렬을 한다.

   - 키: 3, 첫번째 요소: 5
   - 3 < 5 이므로 [3, 5, 2, 4, 1] 이 된다.

2. 세번째 요소를 선택하고, 그 전에 있는 요소와 비교한다.

   - 키: 2, 두번째 요소: 5,
     - 교환 후 [3, 2, 5, 4, 1]
   - 키: 2, 첫번째 요소: 3
     - 교환 후 [2, 3, 5, 4, 1]

3. 네번째 요소를 선택하고 그 전에 있는 요소와 비교한다.

   - 키: 4, 세번째 요소: 5,

     - 교환 후 [2, 3, 4, 5, 1]

   - 키: 4, 두번째 요소: 3,
     - 중단 [2, 3, 4, 5, 1] (키가 더 크다는 말은 이전 요소는 정렬이 되어있다는 의미이다.)

4. 다섯번째 요소를 선택하고 그 전에 있는 요소와 비교한다.

   - 키: 1, 네번째 요소: 5

     - 교환 후 [2, 3, 4, 1, 5]

   - 키: 1, 세번째 요소: 4

     - 교환 후 [2, 3, 1, 4, 5]

   - 키: 1, 두번째 요소: 3

     - 교환 후 [2, 1, 3, 4, 5]

   - 키: 1, 첫번째 요소: 2
     - 교환 후 [1, 2, 3, 4, 5]

이런식으로 정렬을 하는 방식을 삽입 정렬이라고 한다.

키를 인덱스 1부터 n-1까지 선택하는데 n회, 키를 선택한 후 키 이전에 있는 요소와 비교하는데 n번이 들기 때문에 총 O(N^2) 시간이 소요된다.

[소스코드](https://github.com/kangbumkyu/TIL/blob/main/algorithm/sorting/insertion.c#L11)

<br>

### 선택 정렬

- 선택 정렬은 배열 중에 최소값을 찾아서 맨 앞에 있는 요소와 교환을 해가면서 정렬
- 한 번 순회할때마다 맨 앞에 최소값이 위치하게 됨
- 시간 복잡도: O(N^2)

예를 살펴보자. 배열 [3, 5, 4, 2, 1] 을 선택정렬을 사용해 오름차순으로 정렬하면:

1. 첫번째 요소를 제외한 [5, 4, 2, 1] 중 최소값인 1을 첫번째 요소 3과 교환한다.
   [1, 5, 4, 2, 3]
2. 이제 첫번째 요소는 배열에서 가장 최소값이므로 첫번째를 제외한 나머지 배열을 가지고 1번 과정을 반복한다. 그러면 5와 [4, 2, 3]에서 최소값인 2를 교환한다.
   [1, 2, 4, 5, 3]
3. 배열 요소 전부 돌면서 1번 과정을 반복한다.
   [1, 2, 3, 5, 4]
   [1, 2, 3, 4, 5]

최소값을 찾기 위해선 O(N) 시간이 들고, 총 N개 요소에 대해서 작업을 해야 하기 때문에 O(N) \* N = O(N^2) 시간복잡도가 걸린다.

[소스코드](https://github.com/kangbumkyu/TIL/blob/main/algorithm/sorting/selection.c#L23)

<br>

### 퀵 정렬

- 퀵 정렬은 고정값을 하나 잡아서 고정값 보다 작으면 왼쪽, 크면 오른쪽에 위치시키면서 정렬하는 방법이다.
- 한 번 정렬시키고 그 다음엔 좌측 우측을 분할해서 정렬을 하게 되서 O(logN) 깊이 만큼 재귀를 돌아 총 시간 복잡도는 N \* logN = O(NlogN) 이 된다.
<br>

[소스코드](https://github.com/kangbumkyu/TIL/blob/main/algorithm/sorting/quick.c)
